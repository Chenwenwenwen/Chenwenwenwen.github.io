<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on しずか</title>
    <link>https://chenwenwenwen.github.io/posts/</link>
    <description>Recent content in Posts on しずか</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <lastBuildDate>Tue, 05 Jan 2021 14:47:51 +0800</lastBuildDate>
    
	<atom:link href="https://chenwenwenwen.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>利用flex设置了弹性项目如何增大或缩小以适应其弹性容器中可用的空间</title>
      <link>https://chenwenwenwen.github.io/2021/%E5%88%A9%E7%94%A8flex%E8%AE%BE%E7%BD%AE%E4%BA%86%E5%BC%B9%E6%80%A7%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E5%A2%9E%E5%A4%A7%E6%88%96%E7%BC%A9%E5%B0%8F%E4%BB%A5%E9%80%82%E5%BA%94%E5%85%B6%E5%BC%B9%E6%80%A7%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%8F%AF%E7%94%A8%E7%9A%84%E7%A9%BA%E9%97%B4/</link>
      <pubDate>Tue, 05 Jan 2021 14:47:51 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2021/%E5%88%A9%E7%94%A8flex%E8%AE%BE%E7%BD%AE%E4%BA%86%E5%BC%B9%E6%80%A7%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E5%A2%9E%E5%A4%A7%E6%88%96%E7%BC%A9%E5%B0%8F%E4%BB%A5%E9%80%82%E5%BA%94%E5%85%B6%E5%BC%B9%E6%80%A7%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%8F%AF%E7%94%A8%E7%9A%84%E7%A9%BA%E9%97%B4/</guid>
      <description>利用flex设置了弹性项目如何增大或缩小以适应其弹性容器中可用的空间 原理：利用flex属性，原本每个设置为1，当鼠标hover在上面时，改为flex：4撑大
效果：
html代码 &amp;lt;div class=&amp;#34;dz_index-gallery&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;dz_index-gallery-wrapper&amp;#34;&amp;gt; &amp;lt;!-- 重复模块 --&amp;gt; &amp;lt;div class=&amp;#34;dz_index-gallery-list&amp;#34; style=&amp;#34;background-color: skyblue;&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;caption-cont&amp;#34;&amp;gt; &amp;lt;h4 class=&amp;#34;title&amp;#34;&amp;gt;123&amp;lt;/h4&amp;gt; &amp;lt;p class=&amp;#34;intro&amp;#34;&amp;gt;test1&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!--end--&amp;gt; &amp;lt;div class=&amp;#34;dz_index-gallery-list&amp;#34; style=&amp;#34;background-color: yellow;&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;caption-cont&amp;#34;&amp;gt; &amp;lt;h4 class=&amp;#34;title&amp;#34;&amp;gt;231&amp;lt;/h4&amp;gt; &amp;lt;p class=&amp;#34;intro&amp;#34;&amp;gt;test2&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;dz_index-gallery-list&amp;#34; style=&amp;#34;background-color:pink;&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;caption-cont&amp;#34;&amp;gt; &amp;lt;h4 class=&amp;#34;title&amp;#34;&amp;gt;9999&amp;lt;/h4&amp;gt; &amp;lt;p class=&amp;#34;intro&amp;#34;&amp;gt;test3&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;dz_index-gallery-list&amp;#34; style=&amp;#34;background-color:green;&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;caption-cont&amp;#34;&amp;gt; &amp;lt;h4 class=&amp;#34;title&amp;#34;&amp;gt;3333&amp;lt;/h4&amp;gt; &amp;lt;p class=&amp;#34;intro&amp;#34;&amp;gt;test4&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; css代码 &amp;lt;style&amp;gt; .dz_index-gallery { width: 100%; box-sizing: border-box; overflow: hidden; padding: 30px 0; } .</description>
    </item>
    
    <item>
      <title>异步</title>
      <link>https://chenwenwenwen.github.io/2020/%E5%BC%82%E6%AD%A5/</link>
      <pubDate>Thu, 17 Dec 2020 11:53:14 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2020/%E5%BC%82%E6%AD%A5/</guid>
      <description>u## 异步
核心：程序当前运行部分和未来运行部分之间的关系
1.1 分块程序 函数-最常见的块单位，所有块都共享程序作用域和状态
当前无法完成的任务会异步完成
最简单的方法：回调函数（不是最优也不是唯一）
不要同步Ajax请求-&amp;gt; 阻塞所有用户交互
引入异步-&amp;gt;创建函数并指定它在相应某个事件（定时器\ajax\鼠标事件等)后执行
异步控制台 非js标准-&amp;gt;由宿主环境提供
​	不同浏览器和JS环境实现不一致
​	console.log等IO操作可能被阻塞（后台异步执行）
​	解决：1.在JS调试器种使用断点，不要依赖控制台输出
​	2.把对象序列化到一个字符串（JSON.stringify(..))，以强制执行一次&amp;quot;快照&amp;rdquo;
1.2事件循环 ES6内建Promise要求对事件循环队列的调度运行能够直接进行精细控制-&amp;gt;不再只有宿主环境（通常是浏览器）管理
JS引擎再宿主环境内运行-&amp;gt;没有时间概念（仅按需执行代码段）
事件循环队列智能逐一执行（无抢占执行）-&amp;gt;导致setTimeout()等无法准确触发
1.3并行线程 异步≠并行
并行：能够同时发生
进程和线程：多个线程能够共享单个进程得内存
并行和顺序执行可以共存
JS不允许跨线程共享数据 -&amp;gt; 单线程
&amp;ldquo;进程&amp;quot;间若**不交互(互相影响)**则非确定性可接受 -&amp;gt; 执行顺序与结果无关
不确定性（竞态条件）：函数再顺序执行级别上。
1.4并发 单线程事件循环是并发得一种形式
JS一次只能处理一个事件
1.4.1非交互 &amp;ldquo;进程&amp;quot;间若**不交互(互相影响)**则非确定性可接受 -&amp;gt; 执行顺序与结果无关
1.4.2交互 竞态协调交互-&amp;gt;确保执行顺序以避免不确定性（防止竞态）
门闩协调交互-&amp;gt;只有第一名取胜（允许不确定性）
1.4.3协作 并发协作是并发的一种形式
重点不是通过共享作用域中的值进行交互
分解长任务为多批子任务-&amp;gt;允许其他并发进程插入事件循环列中交替执行
1.5任务 任务队列：
​	挂载在事件循环队列中每个tick之后的队列
​	每个tick中出现异步操作会追加到队列末尾-&amp;gt;不会添加新事件
事件循环=末尾追加 ； 任务队列 = 插入
任务循环可以无限循环(类似while)导致无法执行下一个事件循环tick-&amp;gt;一个任务可能引起更多任务追加到同一个队列
任务队列更保证顺序：尽可能早的将来
1.6语句循序 编译器语句重新排序
​	代码的语句顺序和JS引擎执行顺序不一定一致
​	JS引擎在编译期间执行的都是安全优化-&amp;gt;最后可见结果都是一样的</description>
    </item>
    
    <item>
      <title>时间格式化</title>
      <link>https://chenwenwenwen.github.io/2020/%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96/</link>
      <pubDate>Thu, 03 Sep 2020 14:24:50 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2020/%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96/</guid>
      <description>时间格式化 格式化时间函数 // 格式化时间函数 function dateFormat(date, fmt) { let _fmt = fmt || &amp;#39;yyyy-MM-dd hh:mm:ss&amp;#39; let ret const opt = { &amp;#39;y+&amp;#39;: date.getFullYear().toString(), &amp;#39;M+&amp;#39;: (date.getMonth() + 1).toString(), &amp;#39;d+&amp;#39;: date.getDate().toString(), &amp;#39;h+&amp;#39;: date.getHours().toString(), &amp;#39;m+&amp;#39;: date.getMinutes().toString(), &amp;#39;s+&amp;#39;: date.getSeconds().toString() } for (const k in opt) { ret = new RegExp(&amp;#39;(&amp;#39; + k + &amp;#39;)&amp;#39;).exec(_fmt) if (ret) { _fmt = _fmt.replace(ret[1], (ret[1].length === 1) ? (opt[k]) : (opt[k].padStart(ret[1].length, &amp;#39;0&amp;#39;))) } } return _fmt } // 计算YTD、最近24小时、最近7天、最近30天（太平洋时间） const formatDateFilter = { // 获取某个时间点至今  getAll() { const _date = new Date() // 初始时间  const date1 = &amp;#39;2019-12-05 16:00:00&amp;#39; // 取上线日期  // 结束时间  const date2 = dateFormat(_date) // 返回数据  return { confirmed_at_min: date1, confirmed_at_max: date2 } }, // 获取年度时间，即当年1月1号零点至今  getYTD() { const _date = new Date() // 初始时间  const Y1 = _date.</description>
    </item>
    
    <item>
      <title>echart、导出、弹窗组件</title>
      <link>https://chenwenwenwen.github.io/2020/vue-8.27/</link>
      <pubDate>Thu, 27 Aug 2020 14:44:51 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2020/vue-8.27/</guid>
      <description>echart图表相关 把echart表弄成组件，方便管理
&amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div class=&amp;#34;dashboard-container&amp;#34;&amp;gt; &amp;lt;puv-chart :chart-data=&amp;#34;chartData&amp;#34; /&amp;gt; &amp;lt;el-row class=&amp;#34;mt&amp;#34;&amp;gt; &amp;lt;el-col :span=&amp;#34;12&amp;#34;&amp;gt; //equ-chart =equChart  &amp;lt;equ-chart :chart-data=&amp;#34;equipmentData&amp;#34; /&amp;gt; &amp;lt;/el-col&amp;gt; &amp;lt;el-col :span=&amp;#34;12&amp;#34;&amp;gt; &amp;lt;ori-chart :chart-data=&amp;#34;originData&amp;#34; /&amp;gt; &amp;lt;/el-col&amp;gt; &amp;lt;/el-row&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; //导出插件 import puvChart from &amp;#39;./components/puv&amp;#39; import equChart from &amp;#39;./components/equipment&amp;#39; import oriChart from &amp;#39;./components/origin&amp;#39; import dateFormat from &amp;#39;@/utils/dateFormat&amp;#39; export default { name: &amp;#39;Dashboard&amp;#39;, components: { puvChart, equChart, oriChart }, data() { return { chartData: {}, equipmentData: {}, originData: {}, oriTable: [] } }, methods: { // 接口  setDate() { const _query = JSON.</description>
    </item>
    
    <item>
      <title>使用rvm管理多版本Ruby</title>
      <link>https://chenwenwenwen.github.io/2020/rvm/</link>
      <pubDate>Mon, 27 Jul 2020 14:16:12 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2020/rvm/</guid>
      <description>使用rvm管理多版本ruby 一、安装rvm   如果没有安装 curl，先安装
curl sudo apt-get install curl   安装 RVM
\curl -sSL [https://get.rvm.io](https://get.rvm.io/) | bash -s stable 下载连接被墙，解决方法：https://www.cnblogs.com/Dylansuns/p/12309847.html
安装成功：
  加载 RVM，加载后才能使用！！
source ~/.bashrcsource ~/.bash_profilesource ~/.profile  查看版本
rvm -v正常结果：
rvm 1.29.10 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io]   二、安装ruby   看下rvm下的所有ruby版本的程序
rvm list known   安装你想要的ruby版本
rvm install 2.5.8  如果报以下错误
/etc/apt/sources.list 执行下面，两三次
rvm autolibs disable  使用指定版本</description>
    </item>
    
    <item>
      <title>Http网络协议</title>
      <link>https://chenwenwenwen.github.io/2020/http%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Wed, 22 Jul 2020 14:20:27 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2020/http%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</guid>
      <description>根据阅读书籍《图解HTTP》总结的笔记，图片来源《图解HTTP》黑白版pdf
一、了解Web和网络基础 Web是建立在Http协议上通信的。
TCP/IP协议：
   应用层 传输层 网络层（网络互联层） 链路层（数据链路层、网络接口层）     向用户提供应用服务时通信的活动。 对应用层提供处于两台计算机之间的数据传输 处理在网络上流动的数据包。数据包是网络传输的最小单位。 处理连接网络的硬件部分。   TCP/IP协议族内预存了各类通用的应用服务，比如FTP(文件传输协议)和DNS（域名系统）服务就是其中两类。 两个不同性质的协议: TCP（传输控制协议）和UDP(用户数据报协议) 规定了通过怎么样的路径（所谓的传输路线）到达对方的电脑，把数据包传给对方    HTTP协议也处于这层  作用就是在众多选项内选择一条传输路线。     TCP/IP通信传输流
与HTTP关系密切的协议：IP、TCP和DNS 一、负责传输的IP协议   IP网际协议位于网络层，作用是把各种数据包传送给对方。
  确保确实传送到对方需要满足各类条件，其中两个重要条件是IP地址和MAC地址。
  IP地址：指明了节点被分配的地址，
MAC地址：指网卡所属的固定地址。
  IP地址可以和MAC地址进行配对。
  IP地址可变换，但MAC地址基本上不会更改。
  使用ARP协议凭借MAC地址进行通信：
ARP地址是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。
  二、确保可靠性的TCP协议 TCP属于传输层，提供可靠的字节流服务。
字节流服务：为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。
确保数据能够到达目标
为了让数据准确无误的到达目标，采用三次握手策略
TCP的标志：SYN和ACK
1.发送带有SYN标志数据包给对方
2.对方收到后，回复一个带SYN/ACK标志的包以表达确认信息
3.最后发送一个带有ACK的包，表示&amp;quot;握手&amp;quot;结束
三、负责域名解析的DNS   DNS服务是和HTTP协议一样位于应用层的协议，它提供域名到IP地址之间的解析服务。</description>
    </item>
    
    <item>
      <title>2048游戏制作</title>
      <link>https://chenwenwenwen.github.io/2020/2048/</link>
      <pubDate>Wed, 15 Jul 2020 10:44:00 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2020/2048/</guid>
      <description>游戏实现：开始游戏 代码
一、游戏架构设定  UI-HTML、CSS 游戏逻辑-Js、Jquery 游戏数据 动画效果逻辑-js/jquery 支撑逻辑-js  项目目录 css-2048.cssjs-jquery-1.8.2.min.js	main2048.js	showanimation2048.js	support2048.jsindex.html游戏基础设定 通过键盘上下左右进行移动，当界面不可再移动的时候设定为Game over
二、构建页面元素 ​	头部显示游戏名、重新开始游戏按钮、分数
&amp;lt;header&amp;gt;	&amp;lt;h1&amp;gt;2048&amp;lt;/h1&amp;gt;	&amp;lt;a href=&amp;#34;javascript:newgame();&amp;#34; id=&amp;#34;newgamebutton&amp;#34;&amp;gt;New Game&amp;lt;/a&amp;gt;	&amp;lt;p&amp;gt;score:&amp;lt;span id=&amp;#34;score&amp;#34;&amp;gt;0&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/header&amp;gt;​	整个格子宽高总共为500px，每个小格子宽高为100px，每个小格子之间的间隔20px。
&amp;lt;!--小格子--&amp;gt;	&amp;lt;div id=&amp;#34;grid-container&amp;#34;&amp;gt;	//一行为例	&amp;lt;div class=&amp;#34;grid-cell&amp;#34; id=&amp;#34;grid-cell-0-0&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;	&amp;lt;div class=&amp;#34;grid-cell&amp;#34; id=&amp;#34;grid-cell-0-1&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;	&amp;lt;div class=&amp;#34;grid-cell&amp;#34; id=&amp;#34;grid-cell-0-2&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;	&amp;lt;div class=&amp;#34;grid-cell&amp;#34; id=&amp;#34;grid-cell-0-3&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;	&amp;lt;/div&amp;gt;三、游戏逻辑 board 就相当于全部小格子的二维数组 ，存放的是格子的内容
hasConflicted记录是否发生过一个add
board 、hasConflicted数组初始化为一维数组&amp;mdash;&amp;mdash;-&amp;gt;在初始化的时候需要变成二维数组
var board = new Array()var score = 0 //分数初始化为0var hasConflicted = new Array();把移动的模块设置为number-cell-i-jde 小格子，把文字内容存放在board数组，通过updateBoardView()函数去控制显示到number-cell格子
游戏结束：当游戏没有空格且没有游戏空间的时候
四、游戏逻辑交互 以向左移动为例子
首先判断能否向左移动：&amp;mdash;&amp;gt;函数canMoveLeft()实现判断</description>
    </item>
    
    <item>
      <title>LeaveIt主题功能优化</title>
      <link>https://chenwenwenwen.github.io/2020/leaveit%E6%B7%BB%E5%8A%A0%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Fri, 03 Jul 2020 16:28:52 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2020/leaveit%E6%B7%BB%E5%8A%A0%E5%8A%9F%E8%83%BD/</guid>
      <description>一、评论系统 准备工作 LeaveIt主题没有提供评论的功能，因此需要自己写，这里我用的是 Valine 第三方评论系统。必须先注册和创建应用，选着开发版就好。
快速开始 | Valine
应用创建完后，可以去设置里应用KEY看到 APPID、APPKEY 。
Step1 配置Valine 在 config.toml 中加入以下代码（Valine基本配置）
# Valine. # You can get your appid and appkey from https://leancloud.cn # more info please open https://valine.js.org [params.valine] enable = true appId = &amp;#39;XXXXXXXXXXXXXXXXXXXXXXXXXXX&amp;#39; appKey = &amp;#39;XXXXXXXXXXXXXXXXXXXXXXXXXXX&amp;#39; notify = false # mail notifier , https://github.com/xCss/Valine/wiki verify = false # Verification code avatar = &amp;#39;mm&amp;#39; placeholder = &amp;#39;说点什么吧...&amp;#39; visitor = trueappId和appKey换成自己的，详细的配置信息请阅读 配置项 | Valine</description>
    </item>
    
    <item>
      <title>Sql注入基础原理</title>
      <link>https://chenwenwenwen.github.io/2020/sql%E6%B3%A8%E5%85%A5/</link>
      <pubDate>Fri, 03 Jul 2020 10:27:49 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2020/sql%E6%B3%A8%E5%85%A5/</guid>
      <description>一、Sql注入简介 ​	Sql注入攻击是通过恶意的Sql查询或者添加语句插入到应用的输入参数中，再在后台Sql服务器上解析执行进行的攻击。
二、Web程序三层架构 三层架构：界面层、业务逻辑层、数据访问层
区分层次目的：高内聚低耦合的思想
由数据库驱动的Web应用程序依从三层架构的思想也分为了三层：
表示层：访问http://www.xxxx.com，呈现HTML内容
业务逻辑层（领域层）：加载、编译执行index.php，发送HTML文件
数据访问层（存储层）：执行SQL语句，返回数据
三层架构是一种线性关系。
三、Sql 注入漏洞详解 Sql注入产生的原因及威胁 刚刚讲过当我们访问动态网页时, Web 服务器会向数据访问层发起 Sql 查询请求，如果权限验证通过就会执行 Sql 语句。 这种网站内部直接发送的Sql请求一般不会有危险，但实际情况是很多时候需要结合用户的输入数据动态构造 Sql 语句，如果用户输入的数据被构造成恶意 Sql 代码，Web 应用又未对动态构造的 Sql 语句使用的参数进行审查，则会带来意想不到的危险。
Sql 注入带来的威胁主要有如下几点
 猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息。 绕过认证，列如绕过验证登录网站后台。 注入可以借助数据库的存储过程进行提权等操作  查看具体实例
四、判断Sql注入点 通常情况下，可能存在 Sql 注入漏洞的 Url 是类似这种形式 ：http://xxx.xxx.xxx/abcd.php?id=XX 对 Sql 注入的判断，主要有两个方面：
 判断该带参数的 Url 是否存在 Sql 注入？ 如果存在 Sql 注入，那么属于哪种 Sql 注入？  可能存在 Sql 注入攻击的 ASP/PHP/JSP 动态网页中，一个动态网页中可能只有一个参数，有时可能有多个参数。有时是整型参数，有时是字符串型参数，不能一概而论。总之只要是带有参数的 动态网页且此网页访问了数据库，那么就有可能存在 Sql 注入。如果程序员没有足够的安全意识，没有进行必要的字符过滤，存在SQL注入的可能性就非常大。
4.1 判断是否存在Sql注入漏洞 经典：单引号判断法</description>
    </item>
    
    <item>
      <title>在非系统盘安装 WSL</title>
      <link>https://chenwenwenwen.github.io/2020/wsl/</link>
      <pubDate>Thu, 18 Jun 2020 10:51:03 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2020/wsl/</guid>
      <description>在非系统盘安装 WSL 首先在系统中配置
 windows设置 &amp;ndash; 系统 &amp;ndash; 储存 &amp;ndash; 更改新内容的保存位置 &amp;ndash; 新的应用将保持到：非系统盘  然后以管理员身份运行 Windows PowerShell ， 推荐安装 Windows Terminal (Preview) 更加美观
#启动虚拟机平台 Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform #启用Linux子系统 Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux #创建目录 New-Item D:\WSL -ItemType Directory Set-Location D:\WSL #下载安装程序，这个过程比较慢，要多等一段时间 //直接下载安装包更快 Invoke-WebRequest -Uri https://aka.ms/wsl-ubuntu-1604 -OutFile Ubuntu.appx -UseBasicParsing Rename-Item .\Ubuntu.appx Ubuntu1604.zip Expand-Archive .\Ubuntu1804.zip -Verbose #运行程序 cd Ubuntu1804 .\ubuntu1804.exe 检查是否有打开一下Windows功能
按照上面的步骤完成，就可以轻松吃上 WSL 了 ，不过如果安装过程出错呢？看看下面如何重装吧
如何重装   直接把 WSL 整个目录删除
  通过 wslconfig /l 查看版本</description>
    </item>
    
    <item>
      <title>使用nvm管理多版本Node</title>
      <link>https://chenwenwenwen.github.io/2020/nvm/</link>
      <pubDate>Tue, 16 Jun 2020 14:07:01 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2020/nvm/</guid>
      <description>一、下载nvm github上下载nvm最新版本  nvm-noinstall.zip 是绿色免安装版本，但是使用之前需要配置（推荐） nvm-setup.zip： 这是一个安装包，下载之后点击安装，无需配置就可以使用，很方便  二、安装nvm   nvm-noinstall.zip 下载完成解压在C:\dev\nvm。里面的文件列表如下
  双击install.cmd，直接回车，生成目录settings.txt文件。把这个文件剪切到C:\dev\nvm目录中。
（不存在则新建，新建后的txt文件不要修改其文件编码,使用默认的ANSI格式，否则无法正确解析配置文件中的内容 ）
root: C:\dev\nvm （根据自己情况配置） root:后面一定要有一个空格 path: C:\dev\nodejs （根据自己情况配置）path:后面一定要有一个空格 arch: 64 proxy: none node_mirror: http://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ ​ 注意: root:和path: 后面一定要有一个空格否则在安装node的时候不会安装到nvm文件夹下
  配置环境变量
window+r 输入sysdm.cpl 快捷方式打开系统属性面板，在高级里面找到环境变量，或者在我的电脑右击属性——》高级系统设置——》高级-——》环境变量
NVM_HOME：nvm.exe 所在目录&amp;lt;==&amp;gt; setting**s**.txt中的root值 NVM_SYMLINK：node 快捷方式所在的目录 &amp;lt;==&amp;gt; setting**s**.txt中的root值 PATH中添加%NVM_HOME% 和**;**%NVM_SYMLINK% 验证：打开CMD通过set NVM_HOME和 set NVM_SYMLINK 命令查看环境变量是否配置成功
成功则显示如下：
  在cmd输入nvm 查看nvm详细信息，如果出现详细信息，所以已经安装成功，但是在window10 可能会出现 ‘nvm’ 不是内部或外部命令，也不是可运行的程序或批处理文件。这是cmd的问题，我们可以打开window+r输入powershell打开powershell，powershell可以看作是cmd 的升级版   切换node 版本 nvm list查看版本 nvm use 版本号 （切换到node 版本） node -v 查看版本 （确认安装成功） 在vsCode允许node 环境 1.</description>
    </item>
    
    <item>
      <title>如何使用Hugo搭建个人博客</title>
      <link>https://chenwenwenwen.github.io/2020/hugo/</link>
      <pubDate>Fri, 12 Jun 2020 11:07:48 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2020/hugo/</guid>
      <description>Hugo是什么？ Hugo是一个用Go语言编写的静态网站生成器，Hugo一般只需要几秒钟就能生成一个网站（每页少于1毫秒），被称为”世界上最快的网站构建框架“，是最热门的静态网站生成器之一，被广泛采用。
Hugo 官方主页
如何使用Hugo搭建个人博客 Step1：安装Hugo 1.下载Hugo安装
2.下载到安装包，解压后放到x:\xxx\hugo
3.添加环境变量：点击计算机图标-右键-属性-高级系统设置-系统变量-path-添加
4.重启终端，运行 hugo version 。安装成功就能查看到版本号
Step2：创建一个新的Hugo网页 1.进入Hugo官网
2.点击Quick Start ，Step1操作前面已完成，直接开始Step2
3.复制Step2的代码，在cmd上运行。注意这里要把”quickstart“改成“github用户名.github.io-creater!”(这样操作的好处是，上传到GitHub上后方便标识。)
hugo new site quickstart 上面的代码将在名为的文件夹中创建一个新的Hugo网站 quickstart
Step3：添加主题 这里以主题ananke为例：
cd quickstart //记得将quickstart更改为上一步的创建名 git init git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke 将主题添加到站点配置中：
echo &amp;#39;theme = &amp;#34;ananke&amp;#34;&amp;#39; &amp;gt;&amp;gt; config.toml Step4：新建一篇文章 posts:放置文章的文件夹
hugo new posts/test.md 可以用文本文件或 Markdown 编辑器打开文件 post/test.md ，并增加点内容。
PS：默认创建的是草稿类型，需要将draft值改为false才能看到页面
推送新文章 在网站的主目录下
hugo new posts/文章名.md hugo --theme=主题名称 cd public git add -A git commit -m &amp;#34;描述内容&amp;#34; git push -u origin master Step5：开启Hugo服务器 hugo server -D 浏览至http：// localhost：1313 /的新站点。</description>
    </item>
    
  </channel>
</rss>