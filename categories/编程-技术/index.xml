<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程 · 技术 on しずか</title>
    <link>https://chenwenwenwen.github.io/categories/%E7%BC%96%E7%A8%8B-%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 编程 · 技术 on しずか</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <lastBuildDate>Tue, 05 Jan 2021 15:11:16 +0800</lastBuildDate>
    
	<atom:link href="https://chenwenwenwen.github.io/categories/%E7%BC%96%E7%A8%8B-%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JQ实现侧边栏手风琴三级导航菜单Demo</title>
      <link>https://chenwenwenwen.github.io/2021/jq%E5%AE%9E%E7%8E%B0%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%89%8B%E9%A3%8E%E7%90%B4%E4%B8%89%E7%BA%A7%E5%AF%BC%E8%88%AA%E8%8F%9C%E5%8D%95demo/</link>
      <pubDate>Tue, 05 Jan 2021 15:11:16 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2021/jq%E5%AE%9E%E7%8E%B0%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%89%8B%E9%A3%8E%E7%90%B4%E4%B8%89%E7%BA%A7%E5%AF%BC%E8%88%AA%E8%8F%9C%E5%8D%95demo/</guid>
      <description>效果：
html代码 &amp;lt;div class=&amp;#34;dz_pro_nav&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;pro_nav&amp;#34;&amp;gt; &amp;lt;ul class=&amp;#34;nav&amp;#34;&amp;gt; &amp;lt;li&amp;gt; &amp;lt;div class=&amp;#34;fristNav&amp;#34;&amp;gt; &amp;lt;a href=&amp;#34;#&amp;#34; target=&amp;#34;_blank&amp;#34; &amp;gt; &amp;lt;span class=&amp;#34;DXIcon dx-icon_year dz_nav_icon pc&amp;#34;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;h2&amp;gt;一级菜单&amp;lt;/h2&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;!--三角箭头--&amp;gt; &amp;lt;div class=&amp;#34;nav_triangle_1 fristNav_open&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- 二级菜单 --&amp;gt; &amp;lt;ul class=&amp;#34;sub&amp;#34;&amp;gt; &amp;lt;li&amp;gt; &amp;lt;div class=&amp;#34;secoundNav&amp;#34; &amp;gt; &amp;lt;a href=&amp;#34;#&amp;#34; target=&amp;#34;_blank&amp;#34; &amp;gt; &amp;lt;div class=&amp;#34;sub-title&amp;#34;&amp;gt;二级菜单&amp;lt;/div&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;!--三角箭头--&amp;gt; &amp;lt;div class=&amp;#34;nav_triangle_1 secoundNav_open&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- 三级菜单 --&amp;gt; &amp;lt;div class=&amp;#34;thr&amp;#34;&amp;gt; &amp;lt;a class=&amp;#34;thridNav&amp;#34; href=&amp;#34;#&amp;#34; target=&amp;#34;_blank&amp;#34; &amp;gt; &amp;lt;!--三角箭头--&amp;gt; &amp;lt;div class=&amp;#34;nav_triangle_2&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;thr_title&amp;#34;&amp;gt;三级菜单&amp;lt;/div&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; CSS代码 .</description>
    </item>
    
    <item>
      <title>利用flex设置了弹性项目如何增大或缩小以适应其弹性容器中可用的空间</title>
      <link>https://chenwenwenwen.github.io/2021/%E5%88%A9%E7%94%A8flex%E8%AE%BE%E7%BD%AE%E4%BA%86%E5%BC%B9%E6%80%A7%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E5%A2%9E%E5%A4%A7%E6%88%96%E7%BC%A9%E5%B0%8F%E4%BB%A5%E9%80%82%E5%BA%94%E5%85%B6%E5%BC%B9%E6%80%A7%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%8F%AF%E7%94%A8%E7%9A%84%E7%A9%BA%E9%97%B4/</link>
      <pubDate>Tue, 05 Jan 2021 14:47:51 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2021/%E5%88%A9%E7%94%A8flex%E8%AE%BE%E7%BD%AE%E4%BA%86%E5%BC%B9%E6%80%A7%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E5%A2%9E%E5%A4%A7%E6%88%96%E7%BC%A9%E5%B0%8F%E4%BB%A5%E9%80%82%E5%BA%94%E5%85%B6%E5%BC%B9%E6%80%A7%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%8F%AF%E7%94%A8%E7%9A%84%E7%A9%BA%E9%97%B4/</guid>
      <description>原理：利用flex属性，原本每个设置为1，当鼠标hover在上面时，改为flex：4撑大
效果：
html代码 &amp;lt;div class=&amp;#34;dz_index-gallery&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;dz_index-gallery-wrapper&amp;#34;&amp;gt; &amp;lt;!-- 重复模块 --&amp;gt; &amp;lt;div class=&amp;#34;dz_index-gallery-list&amp;#34; style=&amp;#34;background-color: skyblue;&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;caption-cont&amp;#34;&amp;gt; &amp;lt;h4 class=&amp;#34;title&amp;#34;&amp;gt;123&amp;lt;/h4&amp;gt; &amp;lt;p class=&amp;#34;intro&amp;#34;&amp;gt;test1&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!--end--&amp;gt; &amp;lt;div class=&amp;#34;dz_index-gallery-list&amp;#34; style=&amp;#34;background-color: yellow;&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;caption-cont&amp;#34;&amp;gt; &amp;lt;h4 class=&amp;#34;title&amp;#34;&amp;gt;231&amp;lt;/h4&amp;gt; &amp;lt;p class=&amp;#34;intro&amp;#34;&amp;gt;test2&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;dz_index-gallery-list&amp;#34; style=&amp;#34;background-color:pink;&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;caption-cont&amp;#34;&amp;gt; &amp;lt;h4 class=&amp;#34;title&amp;#34;&amp;gt;9999&amp;lt;/h4&amp;gt; &amp;lt;p class=&amp;#34;intro&amp;#34;&amp;gt;test3&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;dz_index-gallery-list&amp;#34; style=&amp;#34;background-color:green;&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;caption-cont&amp;#34;&amp;gt; &amp;lt;h4 class=&amp;#34;title&amp;#34;&amp;gt;3333&amp;lt;/h4&amp;gt; &amp;lt;p class=&amp;#34;intro&amp;#34;&amp;gt;test4&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; css代码 &amp;lt;style&amp;gt; .dz_index-gallery { width: 100%; box-sizing: border-box; overflow: hidden; padding: 30px 0; } .</description>
    </item>
    
    <item>
      <title>异步</title>
      <link>https://chenwenwenwen.github.io/2020/%E5%BC%82%E6%AD%A5/</link>
      <pubDate>Thu, 17 Dec 2020 11:53:14 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2020/%E5%BC%82%E6%AD%A5/</guid>
      <description>u## 异步
核心：程序当前运行部分和未来运行部分之间的关系
1.1 分块程序 函数-最常见的块单位，所有块都共享程序作用域和状态
当前无法完成的任务会异步完成
最简单的方法：回调函数（不是最优也不是唯一）
不要同步Ajax请求-&amp;gt; 阻塞所有用户交互
引入异步-&amp;gt;创建函数并指定它在相应某个事件（定时器\ajax\鼠标事件等)后执行
异步控制台 非js标准-&amp;gt;由宿主环境提供
​	不同浏览器和JS环境实现不一致
​	console.log等IO操作可能被阻塞（后台异步执行）
​	解决：1.在JS调试器种使用断点，不要依赖控制台输出
​	2.把对象序列化到一个字符串（JSON.stringify(..))，以强制执行一次&amp;quot;快照&amp;rdquo;
1.2事件循环 ES6内建Promise要求对事件循环队列的调度运行能够直接进行精细控制-&amp;gt;不再只有宿主环境（通常是浏览器）管理
JS引擎再宿主环境内运行-&amp;gt;没有时间概念（仅按需执行代码段）
事件循环队列智能逐一执行（无抢占执行）-&amp;gt;导致setTimeout()等无法准确触发
1.3并行线程 异步≠并行
并行：能够同时发生
进程和线程：多个线程能够共享单个进程得内存
并行和顺序执行可以共存
JS不允许跨线程共享数据 -&amp;gt; 单线程
&amp;ldquo;进程&amp;quot;间若**不交互(互相影响)**则非确定性可接受 -&amp;gt; 执行顺序与结果无关
不确定性（竞态条件）：函数再顺序执行级别上。
1.4并发 单线程事件循环是并发得一种形式
JS一次只能处理一个事件
1.4.1非交互 &amp;ldquo;进程&amp;quot;间若**不交互(互相影响)**则非确定性可接受 -&amp;gt; 执行顺序与结果无关
1.4.2交互 竞态协调交互-&amp;gt;确保执行顺序以避免不确定性（防止竞态）
门闩协调交互-&amp;gt;只有第一名取胜（允许不确定性）
1.4.3协作 并发协作是并发的一种形式
重点不是通过共享作用域中的值进行交互
分解长任务为多批子任务-&amp;gt;允许其他并发进程插入事件循环列中交替执行
1.5任务 任务队列：
​	挂载在事件循环队列中每个tick之后的队列
​	每个tick中出现异步操作会追加到队列末尾-&amp;gt;不会添加新事件
事件循环=末尾追加 ； 任务队列 = 插入
任务循环可以无限循环(类似while)导致无法执行下一个事件循环tick-&amp;gt;一个任务可能引起更多任务追加到同一个队列
任务队列更保证顺序：尽可能早的将来
1.6语句循序 编译器语句重新排序
​	代码的语句顺序和JS引擎执行顺序不一定一致
​	JS引擎在编译期间执行的都是安全优化-&amp;gt;最后可见结果都是一样的</description>
    </item>
    
    <item>
      <title>时间格式化</title>
      <link>https://chenwenwenwen.github.io/2020/%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96/</link>
      <pubDate>Thu, 03 Sep 2020 14:24:50 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2020/%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96/</guid>
      <description>时间格式化 格式化时间函数 // 格式化时间函数 function dateFormat(date, fmt) { let _fmt = fmt || &amp;#39;yyyy-MM-dd hh:mm:ss&amp;#39; let ret const opt = { &amp;#39;y+&amp;#39;: date.getFullYear().toString(), &amp;#39;M+&amp;#39;: (date.getMonth() + 1).toString(), &amp;#39;d+&amp;#39;: date.getDate().toString(), &amp;#39;h+&amp;#39;: date.getHours().toString(), &amp;#39;m+&amp;#39;: date.getMinutes().toString(), &amp;#39;s+&amp;#39;: date.getSeconds().toString() } for (const k in opt) { ret = new RegExp(&amp;#39;(&amp;#39; + k + &amp;#39;)&amp;#39;).exec(_fmt) if (ret) { _fmt = _fmt.replace(ret[1], (ret[1].length === 1) ? (opt[k]) : (opt[k].padStart(ret[1].length, &amp;#39;0&amp;#39;))) } } return _fmt } // 计算YTD、最近24小时、最近7天、最近30天（太平洋时间） const formatDateFilter = { // 获取某个时间点至今  getAll() { const _date = new Date() // 初始时间  const date1 = &amp;#39;2019-12-05 16:00:00&amp;#39; // 取上线日期  // 结束时间  const date2 = dateFormat(_date) // 返回数据  return { confirmed_at_min: date1, confirmed_at_max: date2 } }, // 获取年度时间，即当年1月1号零点至今  getYTD() { const _date = new Date() // 初始时间  const Y1 = _date.</description>
    </item>
    
    <item>
      <title>echart、导出、弹窗组件</title>
      <link>https://chenwenwenwen.github.io/2020/vue-8.27/</link>
      <pubDate>Thu, 27 Aug 2020 14:44:51 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2020/vue-8.27/</guid>
      <description>echart图表相关 把echart表弄成组件，方便管理
&amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div class=&amp;#34;dashboard-container&amp;#34;&amp;gt; &amp;lt;puv-chart :chart-data=&amp;#34;chartData&amp;#34; /&amp;gt; &amp;lt;el-row class=&amp;#34;mt&amp;#34;&amp;gt; &amp;lt;el-col :span=&amp;#34;12&amp;#34;&amp;gt; //equ-chart =equChart  &amp;lt;equ-chart :chart-data=&amp;#34;equipmentData&amp;#34; /&amp;gt; &amp;lt;/el-col&amp;gt; &amp;lt;el-col :span=&amp;#34;12&amp;#34;&amp;gt; &amp;lt;ori-chart :chart-data=&amp;#34;originData&amp;#34; /&amp;gt; &amp;lt;/el-col&amp;gt; &amp;lt;/el-row&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; //导出插件 import puvChart from &amp;#39;./components/puv&amp;#39; import equChart from &amp;#39;./components/equipment&amp;#39; import oriChart from &amp;#39;./components/origin&amp;#39; import dateFormat from &amp;#39;@/utils/dateFormat&amp;#39; export default { name: &amp;#39;Dashboard&amp;#39;, components: { puvChart, equChart, oriChart }, data() { return { chartData: {}, equipmentData: {}, originData: {}, oriTable: [] } }, methods: { // 接口  setDate() { const _query = JSON.</description>
    </item>
    
    <item>
      <title>Http网络协议</title>
      <link>https://chenwenwenwen.github.io/2020/http%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Wed, 22 Jul 2020 14:20:27 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2020/http%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</guid>
      <description>根据阅读书籍《图解HTTP》总结的笔记，图片来源《图解HTTP》黑白版pdf
一、了解Web和网络基础 Web是建立在Http协议上通信的。
TCP/IP协议：
   应用层 传输层 网络层（网络互联层） 链路层（数据链路层、网络接口层）     向用户提供应用服务时通信的活动。 对应用层提供处于两台计算机之间的数据传输 处理在网络上流动的数据包。数据包是网络传输的最小单位。 处理连接网络的硬件部分。   TCP/IP协议族内预存了各类通用的应用服务，比如FTP(文件传输协议)和DNS（域名系统）服务就是其中两类。 两个不同性质的协议: TCP（传输控制协议）和UDP(用户数据报协议) 规定了通过怎么样的路径（所谓的传输路线）到达对方的电脑，把数据包传给对方    HTTP协议也处于这层  作用就是在众多选项内选择一条传输路线。     TCP/IP通信传输流
与HTTP关系密切的协议：IP、TCP和DNS 一、负责传输的IP协议   IP网际协议位于网络层，作用是把各种数据包传送给对方。
  确保确实传送到对方需要满足各类条件，其中两个重要条件是IP地址和MAC地址。
  IP地址：指明了节点被分配的地址，
MAC地址：指网卡所属的固定地址。
  IP地址可以和MAC地址进行配对。
  IP地址可变换，但MAC地址基本上不会更改。
  使用ARP协议凭借MAC地址进行通信：
ARP地址是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。
  二、确保可靠性的TCP协议 TCP属于传输层，提供可靠的字节流服务。
字节流服务：为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。
确保数据能够到达目标
为了让数据准确无误的到达目标，采用三次握手策略
TCP的标志：SYN和ACK
1.发送带有SYN标志数据包给对方
2.对方收到后，回复一个带SYN/ACK标志的包以表达确认信息
3.最后发送一个带有ACK的包，表示&amp;quot;握手&amp;quot;结束
三、负责域名解析的DNS   DNS服务是和HTTP协议一样位于应用层的协议，它提供域名到IP地址之间的解析服务。</description>
    </item>
    
    <item>
      <title>Sql注入基础原理</title>
      <link>https://chenwenwenwen.github.io/2020/sql%E6%B3%A8%E5%85%A5/</link>
      <pubDate>Fri, 03 Jul 2020 10:27:49 +0800</pubDate>
      
      <guid>https://chenwenwenwen.github.io/2020/sql%E6%B3%A8%E5%85%A5/</guid>
      <description>一、Sql注入简介 ​	Sql注入攻击是通过恶意的Sql查询或者添加语句插入到应用的输入参数中，再在后台Sql服务器上解析执行进行的攻击。
二、Web程序三层架构 三层架构：界面层、业务逻辑层、数据访问层
区分层次目的：高内聚低耦合的思想
由数据库驱动的Web应用程序依从三层架构的思想也分为了三层：
表示层：访问http://www.xxxx.com，呈现HTML内容
业务逻辑层（领域层）：加载、编译执行index.php，发送HTML文件
数据访问层（存储层）：执行SQL语句，返回数据
三层架构是一种线性关系。
三、Sql 注入漏洞详解 Sql注入产生的原因及威胁 刚刚讲过当我们访问动态网页时, Web 服务器会向数据访问层发起 Sql 查询请求，如果权限验证通过就会执行 Sql 语句。 这种网站内部直接发送的Sql请求一般不会有危险，但实际情况是很多时候需要结合用户的输入数据动态构造 Sql 语句，如果用户输入的数据被构造成恶意 Sql 代码，Web 应用又未对动态构造的 Sql 语句使用的参数进行审查，则会带来意想不到的危险。
Sql 注入带来的威胁主要有如下几点
 猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息。 绕过认证，列如绕过验证登录网站后台。 注入可以借助数据库的存储过程进行提权等操作  查看具体实例
四、判断Sql注入点 通常情况下，可能存在 Sql 注入漏洞的 Url 是类似这种形式 ：http://xxx.xxx.xxx/abcd.php?id=XX 对 Sql 注入的判断，主要有两个方面：
 判断该带参数的 Url 是否存在 Sql 注入？ 如果存在 Sql 注入，那么属于哪种 Sql 注入？  可能存在 Sql 注入攻击的 ASP/PHP/JSP 动态网页中，一个动态网页中可能只有一个参数，有时可能有多个参数。有时是整型参数，有时是字符串型参数，不能一概而论。总之只要是带有参数的 动态网页且此网页访问了数据库，那么就有可能存在 Sql 注入。如果程序员没有足够的安全意识，没有进行必要的字符过滤，存在SQL注入的可能性就非常大。
4.1 判断是否存在Sql注入漏洞 经典：单引号判断法</description>
    </item>
    
  </channel>
</rss>